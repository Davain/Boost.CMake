[library Boost.CMake
  [quickbook 1.5]
  [authors [Pfeifer, Daniel]]
  [copyright 2010 2011 Daniel Pfeifer]
  [purpose A collection of CMake modules to simplify the use and development of Boost libraries.]
  [license Distributed under the
    [@http://www.boost.org/LICENSE_1_0.txt Boost Software License, Version 1.0].
  ]
]

[/ why doesnt this expand?]
[/ template cmakeref[command] [@http://www.cmake.org/cmake/help/cmake-2-8-docs.html#command:[command] [command]]
]

[section Introduction]

Boost.CMake is a collection of CMake modules to simplify the use and development
of Boost libraries.

[warning
  Boost.CMake is [*NOT] the official build system for the Boost libraries.

  You might be interested in the official
  [@http://www.boost.org/more/getting_started/index.html Getting Started] section
  on the Boost website. 
]

[section Motivation]
If you want to use a library that is proposed for Boost, you might find the
following instructions in the install section of its documentation:

* download the sources from Boost Vault
* extract the archive into the boost-source directory
* run bjam

Easy, three simple steps and your library is built, [*if] you are used to build
Boost from source. If you usually install Boost prebuilt via an installer or
package management system, you might ask yourself: ["The easiest way to install
this library is to deinstall Boost and then recompile everything? What is this
bjam thing anyway, can't I use Visual Studio?]

With Boost.CMake, the install instruction might look like this:

* download and extract the sources from Boost Vault
* run CMake to generate project files or makefiles
* open the generated project with your IDE
* use your IDE to build and install the library

This instruction is longer and far more ambiguous. It is unclear what is meant
by ['project files], ['makefiles], ['generated project] and ['IDE].
This ambiguity is intended. Unlike bjam, CMake is not a build-system; it is a
meta-build-system, or build-system generator. CMake supports multiple native
build systems on certain platforms. Supported build-systems are specified in
the [@http://www.cmake.org/cmake/help/cmake-2-8-docs.html#section_Generators
Generators section] of the CMake manual.

With Boost.CMake, it is not required to have the Boost source code to build
one individual library. The only requirement is that all its dependencies are
installed. It is still possible to build the whole Boost distribution at once.
In that case, the dependencies of each library do not have to be installed.
[endsect]

[endsect]

[section Getting Started]

[section Required Tools]
To use Boost.CMake you need:

* [@http://www.cmake.org/ CMake]
* your favorite compiler and IDE
* Boost.CMake, of course

Depending on the documentation format you want to create, you will also need
some of those:

* BoostBook
* DocBook
* Quickbook
* doxygen
* xsltproc
* FOP or XEP (requires Java)
* dblatex (requires Python and LaTeX)

[endsect]

[section Install on Ubuntu]
On Ubuntu, Boost.CMake can be installed from
[@https://launchpad.net/~purplekarrot/+archive/ppa my PPA].
This will automatically install all dependancies. 

Open a console window and type in the following:[teletype]

  $ sudo add-apt-repository ppa:purplekarrot/ppa
  $ sudo apt-get update
  $ sudo apt-get install boost-cmake

[endsect]

[section Install on Windows]

[@https://github.com/purpleKarrot/Boost.CMake/archives/master]

[@http://dblatex.sourceforge.net/doc/manual/ch02s03.html]

[endsect]

[section Install on Other Platforms]
If you figured out how to install all the required tools on any other platform,
please let me know.
[endsect]

[section Use the Boost Package in CMake]
If you never worked with CMake before, you should familiarize yourself with the
[@http://www.cmake.org/cmake/help/syntax.html Syntax] and have a look at this
[@http://www.cmake.org/cmake/help/examples.html simple example]. There is also a 
[@http://www.cmake.org/cmake/help/cmake_tutorial.html Turorial] which gives a
good introduction.

If you already used Boost with CMake, then you probably used the FindBoost
module that ships with CMake. When Boost is installed as a CMake package, you
should tell the `find_package()` command to skip this module and search for a
Boost package in ["Config] mode. This is achieved with the `NO_MODULE` keyword:
[c++]

  find_package(Boost "1.46" REQUIRED COMPONENTS filesystem ``[*NO_MODULE]``)
  include("${Boost_USE_FILE}")

The variable `Boost_USE_FILE` is set to the path of a CMake file that can be
included to add the include and library paths.

To link agains Boost libraries, use the function `boost_link_libraries()`. This
function works similar to `target_link_libraries()`, but it only links the
libraries when autolinking is not supported.

  add_executable(hello hello.cpp)
  boost_link_libraries(hello filesystem)

[endsect]
[endsect]

[section Boost.CMake for Boost projects]

In this section I will guide you through the required steps to create a new
Boost library or port an existing Boost library to the CMake build system.

[section Handling Dependencies]
If your project depends on other Boost components, these components should be
installed with CMake. It follows, that you can only CMake-ify a Boost component
once all dependencies have been CMake-ified before.

Depending components should be listed after the `COMPONENTS` keyword in the
`find_package()` command when searching for Boost. It does not matter whether 
these components are header only or not. Dependencies are transitive, that means
if your project depends on Boost.Filesystem and Boost.System you only have to
check for Boost.Filesystem.

Next, include `Boost_DEV_FILE`. This will enable all the commands documented
below.

[note
  The `Boost_USE_FILE` variable is intended for projects that are built with
  CMake and depend on Boost. Projects that are part of Boost should use
  `Boost_DEV_FILE` instead.
]

Your CMakeLists.txt file will look something like this: [python]

  # Distributed under the Boost Software License, Version 1.0.
  # See http://www.boost.org/LICENSE_1_0.txt

  cmake_minimum_required(VERSION 2.8.4)

  find_package(Boost "1.46" REQUIRED COMPONENTS filesystem test NO_MODULE)
  include("${Boost_DEV_FILE}")

In this example, the required components are Boost.Filesystem and Boost.Test.
[endsect]

[section Project Definition]
Call the `boost_project()` command to set a name and description to the project.
If the name of your project contains spaces, you should put the whole project's
name in quotes. 

  boost_project("Example Project"
    AUTHORS
      "John Doe <john@doe.com>"
    DESCRIPTION
      "This is an example project for Boost.CMake."
    DEPENDS
      filesystem
    )

You see that you have to list dependencies again! But there is a difference:
The `COMPONENTS` in the `find_package()` command checks that all the required
components are available when CMake is run, i.e. when someone builds the
project. The `DEPENDS` argument in the `boost_project()` command defines
dependencies for the generated package.

In the shown example that means that everybody who installs our project, should
also install Boost.Filesystem and all its dependencies. To build the project,
Boost.Test is required too (e.g. because the unit tests depend on it).
[endsect]

[section Public Header Files]
Declare your public header files with the `boost_add_headers()` command. This
command will make sure that the headers get installed and can be included by
other Boost projects when doing a monolithic build.

  file(GLOB_RECURSE headers "boost/*.hpp")
  boost_add_headers(${headers})

In the example above, the ["boost] directory is searched recursively for files
that end with .hpp. The directory structure is preserved, so all found headers
get installed to the directory ["<include dir>/boost].

It might be the case that the directory structure should be modified when
installing header files. As an optional argument, you may specify a prefix.
Possible scenarios are:

* Your headers are in ["boost/bar] relative to your CMakeLists.txt and you want
  to install them to ["<include dir>/boost/bar].
  You may omit the prefix parameter or set it to ["].

* Your headers are in the same directory as the CMakeLists.txt and you want to
  install them to ["<include dir>/boost/foo], then you should use ["boost/foo]
  as a prefix.

* Your headers are in ["include/boost/baz] relative to your CMakeLists.txt and
  you want to install them to ["<include dir>/boost/baz]. In that case, you need
  a replacement prefix:
  ["!include/boost/baz!boost/baz!] or ["!include/boost!boost!] or ["!include!!]
  will provide the appropriate result in this case.

  file(GLOB_RECURSE headers "include/*.hpp")
  boost_add_headers(${headers} PREFIX "!include!boost!")

Please note that the use of a globbing expression is [_not recommended] (see
[@http://www.cmake.org/cmake/help/cmake-2-8-docs.html#command:file CMake
manual]), it is better to list all header files explicitely in the
CMakeLists.txt file.

  boost_add_headers(PREFIX "!include!boost!"
    include/foo.hpp
    include/foo/bar.hpp
    include/foo/baz.hpp
    ...
    )

[endsect]

[section Libraries and Executables]
To add a compiled library, use the `boost_add_library()` command instead of
[@http://www.cmake.org/cmake/help/cmake-2-8-docs.html#command:add_library
`add_library`].

  boost_add_library(example example.cpp)

If you need to link other boost libraries, list them after LINK_BOOST_LIBRARIES.
To link third party libraries, list them after LINK_LIBRARIES.

  find_package(ZLIB REQUIRED)

  boost_add_library(example
    SOURCE
      example.cpp
    LINK_BOOST_LIBRARIES
      filesystem
    LINK_LIBRARIES
      ${ZLIB_LIBRARIES}
    )

To add an executable, use the `boost_add_executable()` command instead of
[@http://www.cmake.org/cmake/help/cmake-2-8-docs.html#command:add_executable
`add_executable()`].
This command supports the same arguments as the `boost_add_library()` command.

  boost_add_executable(example
    SOURCE
      exe.cpp
    LINK_BOOST_LIBRARIES
      example
    )

[endsect]

[section Precompiling Headers]
Precompiling header files can speed up compilation by creating a partially
processed version of some header files, and then using that version during
compilations rather than repeatedly parsing the original headers.

To precompile headers, list them after the `PRECOMPILE` keyword in the
`boost_add_library()` or `boost_add_executable()` command. If precompiled
headers are supported, these headers are included in all source files. It is
therefore not required to explicitely include these headers in your source. It
is also not required to guard the inclusion with a PCH_ENABLED macro.

  boost_add_library(example
    SOURCE
      example.cpp
    PRECOMPILE
      "precompile.hpp"
      <boost/filesystem.hpp>
    LINK_BOOST_LIBRARIES
      filesystem
    LINK_LIBRARIES
      ${ZLIB_LIBRARIES}
    )

[endsect]

[section Documentation]
Generate documentation with the 'boost_documentation' command. Use
'boost_add_reference' if you want to include one or more reference sections in
the documentation.
[endsect]

[section Tests]
Use the 'boost_add_test' command to ad a single test case. Use
'boost_test_suite' to add multiple tests at once.
[endsect]

[section Workspace]
If you are a maintainer of more than one Boost library, you may want have some
kind of workspace that contains just your libraries.

You should create a directory and place all your libraries inside. You may also
create a meta-repository and use your libraries as svn:externals or
git-submodules. Also, maybe Ryppl can be used to create such a directory layout?

In the root directory you should create a CMakeLists.txt file with the following
content:

  cmake_minimum_required(VERSION 2.8.4)
  project(Workspace)

  # set this property to OFF when you use Visual Studio Express
  set_property(GLOBAL PROPERTY USE_FOLDERS ON)

  enable_testing()

  set(BOOST_FILESYSTEM_MAINTENANCE ON)
  set(BOOST_QUICKBOOK_MAINTENANCE ON)

  include_directories(${CMAKE_BINARY_DIR}/include)

  add_subdirectory(filesystem)
  add_subdirectory(quickbook)

  include(CPack)
  
Instead of filesystem and quickbook, you will list all your libraries. It is
important, that you also set the BOOST_*_MAINTENANCE variables to ON.
[endsect]

[endsect]

[section Reference]
[include BoostProject.qbk]
[include BoostAddHeaders.qbk]
[include BoostAddLibrary.qbk]
[include BoostAddExecutable.qbk]
[include BoostAddPythonExtension.qbk]
[include BoostAddReference.qbk]
[include BoostDocumentation.qbk]
[include BoostTesting.qbk]
[endsect]

[section Boost.Defrag]
While all Boost libraries and tools may be developed individually, we still want
do be able to release Boost as a whole. Boost.Defrag is a tool that can
aggregate ['fragments][footnote The term ['module] is already used in CMake,
thus we refer to them as ['fragments] to avoid misconceptions.] from different
sources (CVS, SVN, GIT, ...) and create monolithic packages. The packages
[@https://github.com/purpleKarrot/Boost.CMake/archives/master here], as well as
the ubuntu packages in [@https://launchpad.net/~purplekarrot/+archive/ppa my 
PPA] have been created with Boost.Defrag.

[note
  This tool is intended for release managers and package maintainers.
  Neither Boost developers nor clients should need to use Boost.Defrag.
]

For each fragment, Boost.Defrag contains a fragment definition. Such a fragment
definition might look like this:

  boost_fragment(foo
    STABLE DOWNLOAD
      URL "http://example.org/release/foo.tar.gz"
      MD5 "6a0076285cb11b293836"
    UNSTABLE SVN
      URL "http://svn.example.org/foo/trunk/"
      REV "HEAD"
    )

Fragment definitions of libraries under construction should be placed in the
["inclubating] directory. They are usually excluded from packages but can be
activated with the `BOOST_INCLUDE_INCUBATING` option.

Boost.Defrag provides additional files for all fragments that are not properly
ported to Boost.CMake yet. These files are found in the ["provided] directory.
[endsect]

[section Open Issues]

* Running tests is really slow. Currently, CMake repeats the usual compiler
  checks for each single test case. This clearly is not acceptable.

* The ubuntu packages might not satisfy debian quality standards.

* Support for RPM packages is very provisional.

Please let me know about further issues or possible enhancements.

[endsect]
